[
  "constructor(address _contractOwner, address _diamondCutFacet) payable",
  "error CalldataEmptyButInitNotZero()",
  "error FacetAddressIsNotZero()",
  "error FacetAddressIsZero()",
  "error FacetContainsNoCode()",
  "error FunctionAlreadyExists()",
  "error FunctionDoesNotExist()",
  "error FunctionIsImmutable()",
  "error IncorrectFacetCutAction()",
  "error InitReverted(bytes reason)",
  "error InitZeroButCalldataNotEmpty()",
  "error NoSelectorsInFace()",
  "error ZeroAddress()",
  "error OnlyContractOwner()",
  "event DiamondCut(tuple(address facetAddress, uint8 action, bytes4[] functionSelectors)[] _diamondCut, address _init, bytes _calldata)",
  "function diamondCut(tuple(address facetAddress, uint8 action, bytes4[] functionSelectors)[] _diamondCut, address _init, bytes _calldata)",
  "error AlreadyInitialized()",
  "error FeeTooHigh()",
  "error InvalidFee()",
  "function initialize(address _permit2, address _protocolFeeVault, uint256 _maxTokenFee, uint256 _maxFixedNativeFeeAmount)",
  "function facetAddress(bytes4 _functionSelector) view returns (address facetAddress_)",
  "function facetAddresses() view returns (address[] facetAddresses_)",
  "function facetFunctionSelectors(address _facet) view returns (bytes4[] facetFunctionSelectors_)",
  "function facets() view returns (tuple(address facetAddress, bytes4[] functionSelectors)[] facets_)",
  "function supportsInterface(bytes4 _interfaceId) view returns (bool)",
  "event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)",
  "function owner() view returns (address owner_)",
  "function transferOwnership(address _newOwner)",
  "error CannotAuthorizeSelf()",
  "event ExecutionAllowed(address indexed account, bytes4 indexed method)",
  "event ExecutionDenied(address indexed account, bytes4 indexed method)",
  "function addressCanExecuteMethod(bytes4 _selector, address _executor) view returns (bool)",
  "function setBatchCanExecute(bytes4[] _selector, address[] _executor, bool[] _canExecute)",
  "function setCanExecute(bytes4 _selector, address _executor, bool _canExecute)",
  "error InvalidContract()",
  "error UnAuthorized()",
  "event DexAdded(address indexed dexAddress)",
  "event DexRemoved(address indexed dexAddress)",
  "event FunctionSignatureApprovalChanged(address indexed dex, bytes4 indexed functionSignature, bool indexed approved)",
  "function addDex(address _dex)",
  "function batchAddDex(address[] _dexs)",
  "function batchRemoveDex(address[] _dexs)",
  "function batchSetFunctionApprovalBySignature(address[] _dexs, bytes4[] _signatures, bool[] _approval)",
  "function isContractApproved(address _dex) view returns (bool approved)",
  "function isFunctionApproved(address _dex, bytes4 _signature) view returns (bool approved)",
  "function removeDex(address _dex)",
  "function setFunctionApprovalBySignature(address _dex, bytes4 _signature, bool _approval)",
  "error AdapterNotAdded(address adapter)",
  "error BridgeNotAdded(address)",
  "event AdaptersAdded(address[] adapters)",
  "event AdaptersRemoved(address[] adapters)",
  "event BridgeAdded(address[] bridges)",
  "event BridgeRemoved(address[] bridges)",
  "event SelectorToInfoUpdated(address[] bridges, bytes4[] selectors, uint256[] info)",
  "function addAdapters(address[] _adapters)",
  "function addAggregatorsAndBridges(address[] _bridgeAddresses)",
  "function getSelectorInfo(address _bridge, bytes4 _selector) view returns (bool, uint256)",
  "function isAdapterWhitelisted(address _adapter) view returns (bool)",
  "function isBridgeWhitelisted(address _bridge) view returns (bool)",
  "function removeAdapters(address[] _adapters)",
  "function removeAggregatorsAndBridges(address[] _bridgeAddresses)",
  "function updateSelectorInfo(address[] _bridgeAddresses, bytes4[] _selectors, uint256[] _offset)",
  "error IntegratorNotActive()",
  "error IntegratorNotAllowed()",
  "error ShareTooHigh()",
  "event SetDzapFixedNativeFeeAmount(uint256 fee)",
  "event SetDzapTokenFee(uint256 fee)",
  "event SetFixedNativeFee(uint256 fee)",
  "event SetIntegrator(address integrator, uint8[] feeType, tuple(uint256 tokenFee, uint256 fixedNativeFeeAmount, uint256 dzapTokenShare, uint256 dzapFixedNativeShare)[] info)",
  "event SetMaxPlatformFee(uint256 fee)",
  "event SetPlatformFee(uint256 fee)",
  "function calcFixedNativeFees(address _integrator, uint8 _feeType) view returns (uint256 fixedNativeFeeAmount, uint256 dzapShare)",
  "function calcTokenFees(address _integrator, uint8 _feeType, uint256 _amount) view returns (uint256 totalFee, uint256 dzapShare)",
  "function integratorFeeInfo(address _integrator, uint8 _feeType) view returns (tuple(uint256 tokenFee, uint256 fixedNativeFeeAmount, uint256 dzapTokenShare, uint256 dzapFixedNativeShare))",
  "function isIntegratorAllowed(address _integrator) view returns (bool)",
  "function maxFixedNativeFeeAmount() view returns (uint256 _maxFixedNativeFee)",
  "function maxTokenFee() view returns (uint256)",
  "function protocolFeeVault() view returns (address)",
  "function removeIntegrator(address _integrator)",
  "function setIntegratorInfo(address _integrator, uint8[] _feeTypes, tuple(uint256 tokenFee, uint256 fixedNativeFeeAmount, uint256 dzapTokenShare, uint256 dzapFixedNativeShare)[] _feeInfo)",
  "function setProtocolFeeVault(address _protocolFeeVault)",
  "error InsufficientBalance(uint256 amount, uint256 contractBalance)",
  "error NativeTransferFailed()",
  "error NoTransferToNullAddress()",
  "error NotAContract()",
  "error NullAddrIsNotAnERC20Token()",
  "error ReentrancyError()",
  "error WithdrawFailed()",
  "event LogWithdraw(address indexed tokenAddress, address to, uint256 amount)",
  "function executeCallAndWithdraw(address _callTo, bytes _callData, address _token, address _to, uint256 _amount)",
  "function withdraw(address _token, address _to, uint256 _amount)",
  "error AllSwapsFailed()",
  "error ContractCallNotAllowed()",
  "error InvalidAmount()",
  "error InvalidPermit()",
  "error InvalidPermitData()",
  "error NoSwapFromZeroBalance()",
  "error NullAddrIsNotAValidSpender()",
  "error SlippageTooLow(uint256 minAmount, uint256 returnAmount)",
  "error SwapCallFailed(bytes reason)",
  "event MultiSwapped(bytes32 indexed transactionId, address indexed integrator, address indexed sender, address recipient, tuple(address dex, address fromToken, address toToken, uint256 fromAmount, uint256 leftOverFromAmount, uint256 returnToAmount)[] swapInfo)",
  "event Swapped(bytes32 indexed transactionId, address indexed integrator, address indexed sender, address recipient, tuple(address dex, address fromToken, address toToken, uint256 fromAmount, uint256 leftOverFromAmount, uint256 returnToAmount) swapInfo)",
  "event SwappedSingleToken(bytes32 indexed transactionId, address indexed sender, address recipient, tuple(address dex, address fromToken, address toToken, uint256 fromAmount, uint256 leftOverFromAmount, uint256 returnToAmount) swapInfo)",
  "function multiSwap(bytes32 _transactionId, address _integrator, address _recipient, tuple(address callTo, address approveTo, address from, address to, uint256 fromAmount, uint256 minToAmount, bytes swapCallData, bytes permit)[] _data) payable",
  "function multiSwapWithoutRevert(bytes32 _transactionId, address _integrator, address _recipient, tuple(address callTo, address approveTo, address from, address to, uint256 fromAmount, uint256 minToAmount, bytes swapCallData, bytes permit)[] _data) payable",
  "function swap(bytes32 _transactionId, address _integrator, address _recipient, tuple(address callTo, address approveTo, address from, address to, uint256 fromAmount, uint256 minToAmount, bytes swapCallData, bytes permit) _data) payable",
  "function swapErc20ToErc20(bytes32 _transactionId, address _recipient, tuple(address callTo, address approveTo, address from, address to, uint256 fromAmount, uint256 minToAmount, bytes swapCallData, bytes permit) _data)",
  "function swapErc20ToNative(bytes32 _transactionId, address _recipient, tuple(address callTo, address approveTo, address from, address to, uint256 fromAmount, uint256 minToAmount, bytes swapCallData, bytes permit) _data)",
  "function swapNativeToErc20(bytes32 _transactionId, address _recipient, tuple(address callTo, address approveTo, address from, address to, uint256 fromAmount, uint256 minToAmount, bytes swapCallData, bytes permit) _data) payable",
  "function multiSwapAndTransfer(bytes32 _transactionId, address _integrator, address _recipient, tuple(address callTo, address approveTo, address from, address to, uint256 fromAmount, uint256 minToAmount, bytes swapCallData, bytes permit)[] _data) payable",
  "function multiSwapAndTransferWithoutRevert(bytes32 _transactionId, address _integrator, address _recipient, tuple(address callTo, address approveTo, address from, address to, uint256 fromAmount, uint256 minToAmount, bytes swapCallData, bytes permit)[] _data) payable",
  "function swapAndTransfer(bytes32 _transactionId, address _integrator, address _recipient, tuple(address callTo, address approveTo, address from, address to, uint256 fromAmount, uint256 minToAmount, bytes swapCallData, bytes permit) _data) payable",
  "function batchSwap(bytes32 _transactionId, address _integrator, address _recipient, tuple(address callTo, address approveTo, address from, address to, uint256 fromAmount, uint256 minToAmount, bytes swapCallData, bytes permit)[] _data, bool[] _isDirectTransfer) payable",
  "error BridgeCallFailed(bytes reason)",
  "error CannotBridgeToSameNetwork()",
  "error InformationMismatch()",
  "error InvalidLength()",
  "error InvalidSwapDetails()",
  "error UnAuthorizedCall(address)",
  "event BridgeTransferStarted(bytes32 indexed transactionId, address indexed integrator, address indexed sender, tuple(string bridge, bytes to, bytes receiver, address from, bool hasSourceSwaps, bool hasDestinationCall, uint256 minAmountIn, uint256 destinationChainId) bridgeData)",
  "event MultiTokenBridgeTransferStarted(bytes32 indexed transactionId, address indexed integrator, address indexed sender, tuple(string bridge, bytes to, bytes receiver, address from, bool hasSourceSwaps, bool hasDestinationCall, uint256 minAmountIn, uint256 destinationChainId)[] bridgeData)",
  "event SwapBridgeTransferStarted(bytes32 indexed transactionId, address indexed integrator, address indexed sender, tuple(string bridge, bytes to, bytes receiver, address from, bool hasSourceSwaps, bool hasDestinationCall, uint256 minAmountIn, uint256 destinationChainId)[] bridgeData, tuple(address dex, address fromToken, address toToken, uint256 fromAmount, uint256 leftOverFromAmount, uint256 returnToAmount)[] swapInfo)",
  "function bridge(bytes32 _transactionId, address _integrator, tuple(string bridge, bytes to, bytes receiver, address from, bool hasSourceSwaps, bool hasDestinationCall, uint256 minAmountIn, uint256 destinationChainId) _bridgeData, tuple(address callTo, address approveTo, uint256 extraNative, bytes permit, bytes callData) _genericData) payable",
  "function bridgeMultipleTokens(bytes32 _transactionId, address _integrator, tuple(string bridge, bytes to, bytes receiver, address from, bool hasSourceSwaps, bool hasDestinationCall, uint256 minAmountIn, uint256 destinationChainId)[] _bridgeData, tuple(address callTo, address approveTo, uint256 extraNative, bytes permit, bytes callData)[] _genericData) payable",
  "function swapAndBridge(bytes32 _transactionId, address _integrator, tuple(string bridge, bytes to, bytes receiver, address from, bool hasSourceSwaps, bool hasDestinationCall, uint256 minAmountIn, uint256 destinationChainId)[] _bridgeData, tuple(address callTo, address approveTo, address from, address to, uint256 fromAmount, uint256 minToAmount, bytes swapCallData, bytes permit)[] _swapData, tuple(address callTo, address approveTo, uint256 extraNative, bytes permit, bytes callData)[] _genericData) payable",
  "function bridgeMultipleTokensViaTransfer(bytes32 _transactionId, address _integrator, tuple(string bridge, bytes to, bytes receiver, address from, bool hasSourceSwaps, bool hasDestinationCall, uint256 minAmountIn, uint256 destinationChainId)[] _bridgeData, tuple(address transferTo, bytes permit)[] _transferData) payable",
  "function bridgeViaTransfer(bytes32 _transactionId, address _integrator, tuple(string bridge, bytes to, bytes receiver, address from, bool hasSourceSwaps, bool hasDestinationCall, uint256 minAmountIn, uint256 destinationChainId) _bridgeData, tuple(address transferTo, bytes permit) _transferData) payable",
  "function swapAndBridgeViaTransfer(bytes32 _transactionId, address _integrator, tuple(string bridge, bytes to, bytes receiver, address from, bool hasSourceSwaps, bool hasDestinationCall, uint256 minAmountIn, uint256 destinationChainId)[] _bridgeData, tuple(address callTo, address approveTo, address from, address to, uint256 fromAmount, uint256 minToAmount, bytes swapCallData, bytes permit)[] _swapData, tuple(address transferTo, bytes permit)[] _transferData) payable",
  "error AdapterCallFailed(bytes res)",
  "error AdapterNotWhitelisted(address adapter)",
  "event BatchBridgeTransferStart(bytes32 indexed transactionId, address indexed integrator, address indexed sender, tuple(string bridge, bytes to, bytes receiver, address from, bool hasSourceSwaps, bool hasDestinationCall, uint256 minAmountIn, uint256 destinationChainId)[] bridgeData)",
  "event BatchSwapAndBridgeTransferStart(bytes32 indexed transactionId, address indexed integrator, address indexed sender, tuple(string bridge, bytes to, bytes receiver, address from, bool hasSourceSwaps, bool hasDestinationCall, uint256 minAmountIn, uint256 destinationChainId)[] bridgeData, tuple(address dex, address fromToken, address toToken, uint256 fromAmount, uint256 leftOverFromAmount, uint256 returnToAmount)[] swapInfo)",
  "event BridgeTransferStarted(bytes32 transactionId, address indexed integrator, address indexed sender, tuple(string bridge, bytes to, bytes receiver, address from, bool hasSourceSwaps, bool hasDestinationCall, uint256 minAmountIn, uint256 destinationChainId) bridgeData)",
  "event MultiSwapped(bytes32 transactionId, address indexed integrator, address indexed sender, address recipient, tuple(address dex, address fromToken, address toToken, uint256 fromAmount, uint256 leftOverFromAmount, uint256 returnToAmount)[] swapInfo)",
  "event MultiTokenBridgeTransferStarted(bytes32 transactionId, address indexed integrator, address indexed sender, tuple(string bridge, bytes to, bytes receiver, address from, bool hasSourceSwaps, bool hasDestinationCall, uint256 minAmountIn, uint256 destinationChainId)[] bridgeData)",
  "event SwapBridgeTransferStarted(bytes32 transactionId, address indexed integrator, address indexed sender, tuple(string bridge, bytes to, bytes receiver, address from, bool hasSourceSwaps, bool hasDestinationCall, uint256 minAmountIn, uint256 destinationChainId)[] bridgeData, tuple(address dex, address fromToken, address toToken, uint256 fromAmount, uint256 leftOverFromAmount, uint256 returnToAmount)[] swapInfo)",
  "event Swapped(bytes32 transactionId, address indexed integrator, address indexed sender, address recipient, tuple(address dex, address fromToken, address toToken, uint256 fromAmount, uint256 leftOverFromAmount, uint256 returnToAmount) swapInfo)",
  "event SwappedSingleToken(bytes32 transactionId, address indexed sender, address recipient, tuple(address dex, address fromToken, address toToken, uint256 fromAmount, uint256 leftOverFromAmount, uint256 returnToAmount) swapInfo)",
  "function batchBridge(bytes32 _transactionId, address _integrator, tuple(string bridge, bytes to, bytes receiver, address from, bool hasSourceSwaps, bool hasDestinationCall, uint256 minAmountIn, uint256 destinationChainId)[] _bridgeData, tuple(address adapter, bytes data, bytes permit)[] _data) payable",
  "function batchSwapAndBridge(bytes32 _transactionId, address _integrator, tuple(string bridge, bytes to, bytes receiver, address from, bool hasSourceSwaps, bool hasDestinationCall, uint256 minAmountIn, uint256 destinationChainId)[] _bridgeData, tuple(address callTo, address approveTo, address from, address to, uint256 fromAmount, uint256 minToAmount, bytes swapCallData, bytes permit)[] _swapData, tuple(address adapter, bytes data, bytes permit)[] _data) payable",
  "constructor(address _relayReceiver, address _relaySolver)",
  "error Erc20CallFailed(bytes reason)",
  "error NativeCallFailed(bytes reason)",
  "function RELAY_RECEIVER() view returns (address)",
  "function RELAY_SOLVER() view returns (address)",
  "function bridgeMultipleTokensViaRelay(bytes32 _transactionId, address _integrator, tuple(string bridge, bytes to, bytes receiver, address from, bool hasSourceSwaps, bool hasDestinationCall, uint256 minAmountIn, uint256 destinationChainId)[] _bridgeData, tuple(bytes32 requestId, bytes permit)[] _relayData) payable",
  "function bridgeViaRelay(bytes32 _transactionId, address _integrator, tuple(string bridge, bytes to, bytes receiver, address from, bool hasSourceSwaps, bool hasDestinationCall, uint256 minAmountIn, uint256 destinationChainId) _bridgeData, tuple(bytes32 requestId, bytes permit) _relayData) payable",
  "function getRelayAddress() view returns (address receiver, address solver)",
  "function swapAndBridgeViaRelay(bytes32 _transactionId, address _integrator, tuple(string bridge, bytes to, bytes receiver, address from, bool hasSourceSwaps, bool hasDestinationCall, uint256 minAmountIn, uint256 destinationChainId)[] _bridgeData, tuple(address callTo, address approveTo, address from, address to, uint256 fromAmount, uint256 minToAmount, bytes swapCallData, bytes permit)[] _swapData, tuple(bytes32 requestId, bytes permit)[] _relayData) payable",
  "constructor(address _depositAddress)",
  "error InvalidReceiver()",
  "error NotNativeToken()",
  "event GasZipBridgeTransferStarted(bytes32 indexed transactionId, address indexed integrator, address indexed sender, tuple(bytes32 recipient, uint256 destChains, uint256 depositAmount) gasZipData)",
  "event GasZipSwapBridgeTransferStarted(bytes32 indexed transactionId, address indexed integrator, address indexed sender, tuple(bytes32 recipient, uint256 destChains, uint256 depositAmount) gasZipData, tuple(address dex, address fromToken, address toToken, uint256 fromAmount, uint256 leftOverFromAmount, uint256 returnToAmount)[] swapInfo)",
  "function bridgeTokensViaGasZip(bytes32 _transactionId, address _integrator, tuple(bytes32 recipient, uint256 destChains, uint256 depositAmount) _gasZipData) payable",
  "function getGasZipRouter() view returns (address)",
  "function swapAndBridgeTokensViaGasZip(bytes32 _transactionId, address _integrator, tuple(address callTo, address approveTo, address from, address to, uint256 fromAmount, uint256 minToAmount, bytes swapCallData, bytes permit)[] _swapData, tuple(bytes32 recipient, uint256 destChains, uint256 depositAmount) _gasZipData) payable"
]