[
  "error CannotAuthorizeSelf()",
  "error OnlyContractOwner()",
  "error BridgeCallFailed(bytes reason)",
  "error CannotBridgeToSameNetwork()",
  "error InformationMismatch()",
  "error InsufficientBalance(uint256 amount, uint256 contractBalance)",
  "error IntegratorNotAllowed()",
  "error InvalidAmount()",
  "error InvalidLength()",
  "error InvalidPermit()",
  "error InvalidPermitData()",
  "error NativeTransferFailed()",
  "error NoTransferToNullAddress()",
  "error NotAContract()",
  "error NullAddrIsNotAValidSpender()",
  "error NullAddrIsNotAnERC20Token()",
  "error UnAuthorizedCall(address)",
  "error BridgeNotAdded(address)",
  "error UnAuthorized()",
  "error ContractCallNotAllowed()",
  "error InvalidContract()",
  "error InvalidSwapDetails()",
  "error NoSwapFromZeroBalance()",
  "error SlippageTooLow(uint256 minAmount, uint256 returnAmount)",
  "error SwapCallFailed(bytes reason)",
  "error CalldataEmptyButInitNotZero()",
  "error FacetAddressIsNotZero()",
  "error FacetAddressIsZero()",
  "error FacetContainsNoCode()",
  "error FunctionAlreadyExists()",
  "error FunctionDoesNotExist()",
  "error FunctionIsImmutable()",
  "error IncorrectFacetCutAction()",
  "error InitReverted(bytes reason)",
  "error InitZeroButCalldataNotEmpty()",
  "error NoSelectorsInFace()",
  "error AlreadyInitialized()",
  "error FeeTooHigh()",
  "error InvalidFee()",
  "error ZeroAddress()",
  "error IntegratorNotActive()",
  "error ShareTooHigh()",
  "error AllSwapsFailed()",
  "error ReentrancyError()",
  "error WithdrawFailed()",

  "event ExecutionAllowed(address indexed account, bytes4 indexed method)",
  "event ExecutionDenied(address indexed account, bytes4 indexed method)",
  "event BatchBridgeTransferStart(bytes32 transactionId, address integrator, address indexed sender, tuple(string bridge, bytes to, bytes receiver, address from, bool hasSourceSwaps, bool hasDestinationCall, uint256 minAmountIn, uint256 destinationChainId)[] bridgeData)",
  "event BridgeTransferStarted(bytes32 transactionId, address indexed integrator, address indexed sender, tuple(string bridge, bytes to, bytes receiver, address from, bool hasSourceSwaps, bool hasDestinationCall, uint256 minAmountIn, uint256 destinationChainId) bridgeData)",
  "event MultiTokenBridgeTransferStarted(bytes32 transactionId, address indexed integrator, address indexed sender, tuple(string bridge, bytes to, bytes receiver, address from, bool hasSourceSwaps, bool hasDestinationCall, uint256 minAmountIn, uint256 destinationChainId)[] bridgeData)",
  "event BridgeAdded(address[] bridges)",
  "event BridgeRemoved(address[] bridges)",
  "event SelectorToInfoUpdated(address[] bridges, bytes4[] selectors, uint256[] info)",
  "event SwapBridgeTransferStarted(bytes32 transactionId, address indexed integrator, address indexed sender, tuple(string bridge, bytes to, bytes receiver, address from, bool hasSourceSwaps, bool hasDestinationCall, uint256 minAmountIn, uint256 destinationChainId)[] bridgeData, tuple(address dex, address fromToken, address toToken, uint256 fromAmount, uint256 leftOverFromAmount, uint256 returnToAmount)[] swapInfo)",
  "event DexAdded(address indexed dexAddress)",
  "event DexRemoved(address indexed dexAddress)",
  "event FunctionSignatureApprovalChanged(address indexed dex, bytes4 indexed functionSignature, bool indexed approved)",
  "event DiamondCut(tuple(address facetAddress, uint8 action, bytes4[] functionSelectors)[] _diamondCut, address _init, bytes _calldata)",
  "event SetDzapFixedNativeFeeAmount(uint256 fee)",
  "event SetDzapTokenFee(uint256 fee)",
  "event SetFixedNativeFee(uint256 fee)",
  "event SetIntegrator(address integrator, uint8[] feeType, tuple(uint256 tokenFee, uint256 fixedNativeFeeAmount, uint256 dzapTokenShare, uint256 dzapFixedNativeShare)[] info)",
  "event SetMaxPlatformFee(uint256 fee)",
  "event SetPlatformFee(uint256 fee)",
  "event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)",
  "event MultiSwapped(bytes32 transactionId, address indexed integrator, address indexed sender, address recipient, tuple(address dex, address fromToken, address toToken, uint256 fromAmount, uint256 leftOverFromAmount, uint256 returnToAmount)[] swapInfo)",
  "event Swapped(bytes32 transactionId, address indexed integrator, address indexed sender, address recipient, tuple(address dex, address fromToken, address toToken, uint256 fromAmount, uint256 leftOverFromAmount, uint256 returnToAmount) swapInfo)",
  "event SwappedSingleToken(bytes32 transactionId, address indexed sender, address recipient, tuple(address dex, address fromToken, address toToken, uint256 fromAmount, uint256 leftOverFromAmount, uint256 returnToAmount) swapInfo)",
  "event LogWithdraw(address indexed tokenAddress, address to, uint256 amount)",

  "function addressCanExecuteMethod(bytes4 _selector, address _executor) view returns (bool)",
  "function setBatchCanExecute(bytes4[] _selector, address[] _executor, bool[] _canExecute)",
  "function setCanExecute(bytes4 _selector, address _executor, bool _canExecute)",
  "function batchBridgeCall(bytes32 _transactionId, address _integrator, tuple(address callTo, address approveTo, uint256 extraNative, bytes permit, bytes callData)[] _crossChainData, tuple(string bridge, bytes to, bytes receiver, address from, bool hasSourceSwaps, bool hasDestinationCall, uint256 minAmountIn, uint256 destinationChainId)[] _bridgeData, tuple(address transferTo, bytes permit)[] _transferData) payable",
  "function addAggregatorsAndBridges(address[] _bridgeAddresses)",
  "function getSelectorInfo(address _bridge, bytes4 _selector) view returns (bool, uint256)",
  "function isWhitelisted(address _bridge) view returns (bool)",
  "function removeAggregatorsAndBridges(address[] _bridgeAddresses)",
  "function updateSelectorInfo(address[] _bridgeAddresses, bytes4[] _selectors, uint256[] _offset)",
  "function bridge(bytes32 _transactionId, address _integrator, tuple(string bridge, bytes to, bytes receiver, address from, bool hasSourceSwaps, bool hasDestinationCall, uint256 minAmountIn, uint256 destinationChainId) _bridgeData, tuple(address callTo, address approveTo, uint256 extraNative, bytes permit, bytes callData) _genericData) payable",
  "function bridgeMultipleTokens(bytes32 _transactionId, address _integrator, tuple(string bridge, bytes to, bytes receiver, address from, bool hasSourceSwaps, bool hasDestinationCall, uint256 minAmountIn, uint256 destinationChainId)[] _bridgeData, tuple(address callTo, address approveTo, uint256 extraNative, bytes permit, bytes callData)[] _genericData) payable",
  "function swapAndBridge(bytes32 _transactionId, address _integrator, tuple(string bridge, bytes to, bytes receiver, address from, bool hasSourceSwaps, bool hasDestinationCall, uint256 minAmountIn, uint256 destinationChainId)[] _bridgeData, tuple(address callTo, address approveTo, address from, address to, uint256 fromAmount, uint256 minToAmount, bytes swapCallData, bytes permit)[] _swapData, tuple(address callTo, address approveTo, uint256 extraNative, bytes permit, bytes callData)[] _genericData) payable",
  "function addDex(address _dex)",
  "function batchAddDex(address[] _dexs)",
  "function batchRemoveDex(address[] _dexs)",
  "function batchSetFunctionApprovalBySignature(address[] _dexs, bytes4[] _signatures, bool[] _approval)",
  "function isContractApproved(address _dex) view returns (bool approved)",
  "function isFunctionApproved(address _dex, bytes4 _signature) view returns (bool approved)",
  "function removeDex(address _dex)",
  "function setFunctionApprovalBySignature(address _dex, bytes4 _signature, bool _approval)",
  "function diamondCut(tuple(address facetAddress, uint8 action, bytes4[] functionSelectors)[] _diamondCut, address _init, bytes _calldata)",
  "function initialize(address _permit2, address _protocolFeeVault, uint256 _maxTokenFee, uint256 _maxFixedNativeFeeAmount)",
  "function facetAddress(bytes4 _functionSelector) view returns (address facetAddress_)",
  "function facetAddresses() view returns (address[] facetAddresses_)",
  "function facetFunctionSelectors(address _facet) view returns (bytes4[] facetFunctionSelectors_)",
  "function facets() view returns (tuple(address facetAddress, bytes4[] functionSelectors)[] facets_)",
  "function supportsInterface(bytes4 _interfaceId) view returns (bool)",
  "constructor(address _contractOwner, address _diamondCutFacet) payable",
  "function calcFixedNativeFees(address _integrator, uint8 _feeType) view returns (uint256 fixedNativeFeeAmount, uint256 dzapShare)",
  "function calcTokenFees(address _integrator, uint8 _feeType, uint256 _amount) view returns (uint256 totalFee, uint256 dzapShare)",
  "function integratorFeeInfo(address _integrator, uint8 _feeType) view returns (tuple(uint256 tokenFee, uint256 fixedNativeFeeAmount, uint256 dzapTokenShare, uint256 dzapFixedNativeShare))",
  "function isIntegratorAllowed(address _integrator) view returns (bool)",
  "function maxFixedNativeFeeAmount() view returns (uint256 _maxFixedNativeFee)",
  "function maxTokenFee() view returns (uint256)",
  "function protocolFeeVault() view returns (address)",
  "function removeIntegrator(address _integrator)",
  "function setIntegratorInfo(address _integrator, uint8[] _feeTypes, tuple(uint256 tokenFee, uint256 fixedNativeFeeAmount, uint256 dzapTokenShare, uint256 dzapFixedNativeShare)[] _feeInfo)",
  "function setProtocolFeeVault(address _protocolFeeVault)",
  "function owner() view returns (address owner_)",
  "function transferOwnership(address _newOwner)",

  "function multiSwap(bytes32 _transactionId, address _integrator, address _recipient, tuple(address callTo, address approveTo, address from, address to, uint256 fromAmount, uint256 minToAmount, bytes swapCallData, bytes permit)[] _data) payable",
  "function multiSwapWithoutRevert(bytes32 _transactionId, address _integrator, address _recipient, tuple(address callTo, address approveTo, address from, address to, uint256 fromAmount, uint256 minToAmount, bytes swapCallData, bytes permit)[] _data) payable",
  "function swap(bytes32 _transactionId, address _integrator, address _recipient, tuple(address callTo, address approveTo, address from, address to, uint256 fromAmount, uint256 minToAmount, bytes swapCallData, bytes permit) _data) payable",
  "function swapErc20ToEc20(bytes32 _transactionId, address _recipient, tuple(address callTo, address approveTo, address from, address to, uint256 fromAmount, uint256 minToAmount, bytes swapCallData, bytes permit) _data)",
  "function swapErc20ToNative(bytes32 _transactionId, address _recipient, tuple(address callTo, address approveTo, address from, address to, uint256 fromAmount, uint256 minToAmount, bytes swapCallData, bytes permit) _data)",
  "function swapNativeToErc20(bytes32 _transactionId, address _recipient, tuple(address callTo, address approveTo, address from, address to, uint256 fromAmount, uint256 minToAmount, bytes swapCallData, bytes permit) _data) payable",
  "function executeCallAndWithdraw(address _callTo, bytes _callData, address _token, address _to, uint256 _amount)",
  "function withdraw(address _token, address _to, uint256 _amount)",

  "function bridgeMultipleTokensViaTransfer(bytes32 _transactionId, address _integrator, tuple(string bridge, bytes to, bytes receiver, address from, bool hasSourceSwaps, bool hasDestinationCall, uint256 minAmountIn, uint256 destinationChainId)[] _bridgeData, tuple(address transferTo, bytes permit)[] _transferData) payable",
  "function bridgeViaTransfer(bytes32 _transactionId, address _integrator, tuple(string bridge, bytes to, bytes receiver, address from, bool hasSourceSwaps, bool hasDestinationCall, uint256 minAmountIn, uint256 destinationChainId) _bridgeData, tuple(address transferTo, bytes permit) _transferData) payable"
]
